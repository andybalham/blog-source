# Creating a hybrid OpenAPI client

- Using composition over inheritance when creating a hybrid OpenAPI client

In the previous parts in this [series](TODO), I discovered the [TODO: OpenAPI package](TODO), used it to verify [REST API](TODO) payloads, and then used it to create a class that can use an [OpenAPI specification](TODO) to become a dynamic API client. At the end of the [last part](TODO), I compared the resulting client with a static client generated by [Visual Studio](TODO). I liked the strong-typing of the static approach, but didn't like the quantity of generated code I would have to own.

With this in mind, I wondered if I could create a client class that is a hybrid of the two. An example usage is shown below.

```csharp
var client =
    await PetstoreHybridOpenApiClient.CreateAsync(
        new Uri("http://petstore.swagger.io"));

await client.AddPetAsync(new Pet { Name = "Luna" });

Pet pet = await client.GetPetByIdAsync(1);

ICollection<Pet> pets = await client.FindPetsByStatusAsync([Anonymous.Sold]);
```

As an additional challenge, I decided to try implementing it all without resorting to inheritance. As someone who has used object orientation for a long time, my first thought is often to start creating subclasses. However, I am aware of the option to use [composition over inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance). So I thought it would be interesting to try that and see how it felt.

## TODO

```csharp
public class PetstoreHybridClient
{
    private readonly OpenApiClientV2 _client;

    private PetstoreHybridClient(OpenApiClientV2 client)
    {
        _client = client;

    public static async Task<PetstoreHybridClient>CreateAsync(Uri domainUri)
    {
        return
            await HybridOpenApiClient.CreateAsync(
                domainUri, client => new PetstoreHybridClient(client));
    }
}
```

```csharp
public static class HybridOpenApiClient
{
    public static async Task<T> CreateAsync<T>(
        Uri domainUri, Func<OpenApiClientV2, T> newHybridClient) where T : class
    {
        var openApiJson = LoadOpenApiJsonForType<T>();

        var client = await OpenApiClientV2.CreateAsync(openApiJson, domainUri);

        return newHybridClient(client);
    }
}
```

![Properties of the OpenAPI document file](openapi-document-file-properties)

## Adding the API methods

```csharp
public async Task AddPetAsync(
    Pet body)
{
    await _client.PerformAsync(
        "addPet",
        [
            ("body", HybridOpenApiClient.Serialize(body)),
        ]);
}
```

TODO: Mention the attributes on the generated classes:

```csharp
public partial class Pet
{
    // <snip>

    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    public string Name { get; set; }

    // <snip>
}
```

// TODO: Mention serialization helpers

```csharp
private static readonly JsonSerializerSettings _serializerSettings =
    new()
    {
        MissingMemberHandling = MissingMemberHandling.Ignore,
        NullValueHandling = NullValueHandling.Ignore,
        Converters = [new StringEnumConverter()],
    };

public static string Serialize(object value)
{
    if (value == null)
    {
        return null;
    }

    var valueJson = JsonConvert.SerializeObject(value, _serializerSettings);

    var isJsonString = valueJson.StartsWith("\"");

    if (isJsonString)
    {
        return valueJson.Trim('"');
    }

    return valueJson;
}

public static T Deserialize<T>(JsonResponse response)
{
    return JsonConvert.DeserializeObject<T>(response.Payload, _serializerSettings);
}
```

```csharp
  public async Task<Pet> GetPetByIdAsync(
      long petId)
  {
      var response =
          await _client.PerformAsync(
              "getPetById",
              [
                  ("petId", HybridOpenApiClient.Serialize(petId)),
              ]);

      return HybridOpenApiClient.Deserialize<Pet>(response);
  }
```

## Adding and overriding default behaviour

```csharp
public static class HybridOpenApiClient
{
    public static async Task<T> CreateAsync<T>(
        Uri domainUri, Func<OpenApiClientV2, T> newHybridClient) where T : class
    {
        // <snip>

        client.OnFailure = OnFailure;

        return newHybridClient(client);
    }

    public static void OnFailure(
        string operationId,
        IEnumerable<(string, string)> parameters,
        JsonResponse response)
    {
        if (response.HttpStatusCode.HasValue)
        {
            throw new OpenApiException(
                $"{operationId} received {(int)response.HttpStatusCode}: " +
                    $"{string.Join(", ", response.FailureReasons)}",
                response.HttpStatusCode.Value);
        }

        throw new OpenApiException(
            $"{operationId} failed: " +
            $"{string.Join(", ", response.FailureReasons)}",
            response.Exception);
    }
}
```

```csharp
private PetstoreHybridClient(OpenApiClientV2 client)
{
    _client = client;

    _client.OnSuccess =
        (o, p, r) =>
            {
                MyHybridClientHelpers.LogSuccess(o, r);
                HybridOpenApiClient.OnSuccess(o, p, r);
            };

    _client.OnFailure =
        (o, p, r) =>
        {
            MyHybridClientHelpers.LogFailure(o, r);
            HybridOpenApiClient.OnFailure(o, p, r);
        };
}
```

## Generation considerations

```csharp
public async Task<ICollection<Pet>> FindPetsByStatusAsync(
    IEnumerable<Anonymous> status)
{
    // Q: How would we know to do ..Select and not just serialize the parameter?
    // A: "parameters": [ { "type": "array" } ]

    var response =
        await _client.PerformAsync(
            "findPetsByStatus",
            [
                ..status.Select(s => ("status", HybridOpenApiClient.Serialize(s))),
            ]);

    return HybridOpenApiClient.Deserialize<ICollection<Pet>>(response);
}
```

## Comparison with a base client

```csharp
public class PetstoreHybridClientSubclass : HybridOpenApiClientBase
{
    // Base overrides

    protected override void OnSuccess(
        string operationId,
        IEnumerable<(string, string)> parameters,
        JsonResponse response)
    {
        MyHybridClientHelpers.LogSuccess(operationId, response);
        base.OnSuccess(operationId, parameters, response);
    }

    protected override void OnFailure(
        string operationId,
        IEnumerable<(string, string)> parameters,
        JsonResponse response)
    {
        MyHybridClientHelpers.LogFailure(operationId, response);
        base.OnFailure(operationId, parameters, response);
    }

    // API methods

    public async Task AddPetAsync(
        Pet body)
    {
        await Client.PerformAsync(
            "addPet",
            [
                ("body", Serialize(body)),
            ]);
    }
}
```

## Links

- [Wikipedia - Composition over inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance)

  - > Composition over inheritance (or composite reuse principle) in object-oriented programming (OOP) is the principle that classes should favor polymorphic behavior and code reuse by their composition (by containing instances of other classes that implement the desired functionality) over inheritance from a base or parent class.

  - > To favor composition over inheritance is a design principle that gives the design higher flexibility. It is more natural to build business-domain classes out of various components than trying to find commonality between them and creating a family tree. In other words, it is better to compose what an object can do (has-a) than extend what it is (is-a).

  - > One common drawback of using composition instead of inheritance is that methods being provided by individual components may have to be implemented in the derived type, even if they are only forwarding methods. In contrast, inheritance does not require all of the base class's methods to be re-implemented within the derived class.
    - C# provides default interface methods since version 8.0 which allows to define body to interface member.

- [Thoughtworks - Composition vs. Inheritance: How to Choose?](https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose)

  - > Composition is fairly easy to understand - we can see composition in everyday life: a chair has legs, a wall is composed of bricks and mortar, and so on. While the definition of inheritance is simple, it can become a complicated, tangled thing when used unwisely. Inheritance is more of an abstraction that we can only talk about, not touch directly. Though it is possible to mimic inheritance using composition in many situations, it is often unwieldy to do so. The purpose of composition is obvious: make wholes out of parts. The purpose of inheritance is a bit more complex because inheritance serves two purposes, semantics and mechanics.

  - > Inheritance captures semantics (meaning) in a classification hierarchy (a taxonomy), arranging concepts from generalized to specialized, grouping related concepts in subtrees, and so on. Inheritance captures mechanics by encoding the representation of the data (fields) and behavior (methods) of a class and making it available for reuse and augmentation in subclasses. Mechanically, the subclass will inherit the implementation of the superclass and thus also its interface.

  - Perhaps the following guideline could be used. I.e., start with composition, but switch to inheritance if the need arises:

    - > If you find that you are using a component to provide the vast majority of your functionality, creating forwarding methods on your class to call the component’s methods, exposing the component’s fields, etc., consider whether inheritance - for some or all of the desired behavior - might be more appropriate.

- [Code Maze - Composition vs Inheritance in C#](https://code-maze.com/csharp-composition-vs-inheritance/)

  - > So, we should use inheritance if:
    >
    > - There is an “is-a” relationship between classes (X is a Y)
    > - The derived class can have all the functionality of the base class
    >
    > For all other instances, the composition is the preferred choice.
